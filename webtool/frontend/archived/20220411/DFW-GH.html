<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DWF-GH</title>

    <!-- 引入标准bootstrap文件和jQuery文件 -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap-theme.min.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"></script>
	<script src="lib/three.js"></script>
	<script src="lib/js/loaders/STLLoader.js"></script>
	<script src="lib/js/controls/OrbitControls.js"></script>
	<script src="lib/js/libs/stats.min.js"></script>
	<script src="lib/js/libs/dat.gui.min.js"></script>
	<script src="js/FileSaver.js"></script>

    <!-- 引入自定义的css和js -->
    <link rel="stylesheet" type="text/css" href="css/main.css">
	
	<!-- 接口 -->
	<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
	<script language="javascript">
		function getInputs(){
		
		    var content_done;
			var textfile_done;
			
			if (window.XMLHttpRequest)
			{ 
				textfile_done = new XMLHttpRequest(); 
			}
			textfile_done.onreadystatechange = function ()
			{   
			
				if (textfile_done.readyState == 4 && textfile_done.status == 200)
				{ 
					content_done = textfile_done.responseText;
					arr_done = content_done.split('\r\n');
					//console.log(arr_done);
					if (arr_done[0]=="1"){
						var pointdata = [];
						for (var i = 0; i < points.length; i++) {
							pointdata.push(points[i].x*2, 500-points[i].y*2);
						}
						var reduce_rate=document.getElementById("reduce_rate").value;
						var tolerance_of_edge_length=document.getElementById("tolerance_of_edge_length").value;
						var length_constraint_maltiplier=document.getElementById("length_constraint_maltiplier").value;
						var boundary_constraint_magnitude=document.getElementById("boundary_constraint_magnitude").value;
						var perp_steps=document.getElementById("perp_steps").value;
						var minumum_radius=document.getElementById("minumum_radius").value;
						var maximum_radius=document.getElementById("maximum_radius").value;
						value_inputs = {
							"canvas_points": pointdata,
							"reduce_rate": reduce_rate,
							"tolerance_of_edge_length": tolerance_of_edge_length,
							"length_constraint_maltiplier": length_constraint_maltiplier,
							"boundary_constraint_magnitude": boundary_constraint_magnitude,
							"perp_steps": perp_steps,
							"minumum_radius": minumum_radius,
							"maximum_radius": maximum_radius
						};
						axios({
							// headers:{'Cache-Control':'no-cache'},
							method: 'post',
							//url: 'http://127.0.0.1:8888/ghHere/ep/predict/?delay=900&interval=15',
							url: 'http://128.91.16.228:8888/ghHere/ep/predict/?delay=900&interval=1',
							data: value_inputs
						}).then(function (response){
							console.log(response.data);
							// let fp = response.data.fp
						}).catch(function(err){
							console.log(err)
						});
						// alert(value_inputs);
						
						// location.reload();
						console.log(value_inputs);
						
						setTimeout(function(){
							console.log("3 second to wait the server to remove the previous stl file");
							location.reload(true) //refresh the web page
						},3000);
					} else { 
					    window.alert("Ops! The server is responding to other requests. Please try again later.");
					}
				}
			}
			
			var ran = Math.round(Math.random()*100000000).toString();
			textfile_done.open("GET", '../ghBackend/media/Default/done.txt'+'?'+ran, true);
			textfile_done.send();
			
		}
	</script>
</head>

<body>
	<div id="container-item" style="position:absolute; top:20px; left:40px; width: 350px; display:block;">
	    <span class="glyphicon glyphicon-asterisk" style="font-size:20px">Geometric Control Panel</span>
	</div>
	<div id="container" style="position:absolute; top:130px; left:40px; width:260px; height:260px; float:left; display:block;">
	    <canvas id="canvas" width="250" height="250" style="border: 3px solid black"></canvas>
    </div>
	<div id="container-item" style="position:absolute; top:60px; left:0px; width: 340px; display:block;">
	    <ul class="tabs" data-tab>
			<button id="btn_set_3poi" type="button" class="btn btn-default" onclick="set_3poi()" style="float:left; font-size:10px;">
				<span class="glyphicon glyphicon-asterisk" style="font-size:10px">3 points</span>
			</button>
			<script type='text/javascript'>
				function set_3poi() {
					function Point(x, y) {
						this.x = x;
						this.y = y;
						}
						//圆圈对象
					function Circle(x, y) {
						this.x = x;
						this.y = y;
						this.radius = 5;
						this.color = "blue";
						//拖拽点的标记
						this.isSelected = false;
						}
					points = [];
					circles = [];
					var point=new Point(25,25);
					points.push(point);
					var circle=new Circle(25,25);
					circles.push(circle);
					var point=new Point(225,175);
					points.push(point);
					var circle=new Circle(225,175);
					circles.push(circle);
					var point=new Point(25,175);
					points.push(point);
					var circle=new Circle(25,175);
					circles.push(circle);
					const canvas = document.getElementById('canvas');
					const context = canvas.getContext('2d');
					context.clearRect(0,0,canvas.width,canvas.height);
					for(var i=0; i<circles.length; i++) {
						var circle = circles[i];
						context.globalAlpha = 0.85;
						context.beginPath();
						context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
						context.fillStyle = circle.color;
						context.strokeStyle = "black";
						context.fill();
						context.stroke();
					}
					context.beginPath();
					context.lineWidth = 2;
					context.moveTo(points[0].x,points[0].y);
					for (var i = 0; i < points.length; i++) {
					context.lineTo(points[i].x, points[i].y);
					}
					context.lineTo(points[0].x, points[0].y);
					context.closePath();
					context.fillStyle="rgb(128,128,128)";
					context.fill();
					context.strokeStyle="black";
					context.stroke();
					for (var i = 0; i < 10; i++) {
						context.beginPath();
						context.lineWidth = 1;
						var xx = points[0].x + (points[points.length-1].x-points[0].x)*i/9;
						var yy = points[0].y + (points[points.length-1].y-points[0].y)*i/9;
						context.moveTo(xx,yy);
						context.lineTo(xx-7, yy+3);
						context.closePath();
						context.fillStyle="rgb(128,128,128)";
						context.fill();
						context.strokeStyle="black";
						context.stroke();
					}
				}
			</script>
		    <button id="btn_set_4poi" type="button" class="btn btn-default" onclick="set_4poi()" style="float:left; font-size:10px;">
				<span class="glyphicon glyphicon-asterisk" style="font-size:10px">4 points</span>
			</button>
			<script type='text/javascript'>
				function set_4poi() {
					function Point(x, y) {
						this.x = x;
						this.y = y;
						}
						//圆圈对象
					function Circle(x, y) {
						this.x = x;
						this.y = y;
						this.radius = 5;
						this.color = "blue";
						//拖拽点的标记
						this.isSelected = false;
						}
					points = [];
					circles = [];
					var point=new Point(25,25);
					points.push(point);
					var circle=new Circle(25,25);
					circles.push(circle);
					var point=new Point(225,125);
					points.push(point);
					var circle=new Circle(225,125);
					circles.push(circle);
					var point=new Point(225,175);
					points.push(point);
					var circle=new Circle(225,175);
					circles.push(circle);
					var point=new Point(25,100);
					points.push(point);
					var circle=new Circle(25,100);
					circles.push(circle);
					const canvas = document.getElementById('canvas');
					const context = canvas.getContext('2d');
					context.clearRect(0,0,canvas.width,canvas.height);
					for(var i=0; i<circles.length; i++) {
						var circle = circles[i];
						context.globalAlpha = 0.85;
						context.beginPath();
						context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
						context.fillStyle = circle.color;
						context.strokeStyle = "black";
						context.fill();
						context.stroke();
					}
					context.beginPath();
					context.lineWidth = 2;
					context.moveTo(points[0].x,points[0].y);
					for (var i = 0; i < points.length; i++) {
					context.lineTo(points[i].x, points[i].y);
					}
					context.lineTo(points[0].x, points[0].y);
					context.closePath();
					context.fillStyle="rgb(128,128,128)";
					context.fill();
					context.strokeStyle="black";
					context.stroke();
					for (var i = 0; i < 10; i++) {
						context.beginPath();
						context.lineWidth = 1;
						var xx = points[0].x + (points[points.length-1].x-points[0].x)*i/9;
						var yy = points[0].y + (points[points.length-1].y-points[0].y)*i/9;
						context.moveTo(xx,yy);
						context.lineTo(xx-7, yy+3);
						context.closePath();
						context.fillStyle="rgb(128,128,128)";
						context.fill();
						context.strokeStyle="black";
						context.stroke();
					}
				}
			</script>
			<button id="btn_set_5poi" type="button" class="btn btn-default" onclick="set_5poi()" style="float:left; font-size:10px;">
				<span class="glyphicon glyphicon-asterisk" style="font-size:10px">5 points</span>
			</button>
			<script type='text/javascript'>
				function set_5poi() {
					function Point(x, y) {
						this.x = x;
						this.y = y;
						}
						//圆圈对象
					function Circle(x, y) {
						this.x = x;
						this.y = y;
						this.radius = 5;
						this.color = "blue";
						//拖拽点的标记
						this.isSelected = false;
						}
					points = [];
					circles = [];
					var point=new Point(25,25);
					points.push(point);
					var circle=new Circle(25,25);
					circles.push(circle);
					var point=new Point(225,125);
					points.push(point);
					var circle=new Circle(225,125);
					circles.push(circle);
					var point=new Point(225,175);
					points.push(point);
					var circle=new Circle(225,175);
					circles.push(circle);
					var point=new Point(100,112);
					points.push(point);
					var circle=new Circle(100,112);
					circles.push(circle);
					var point=new Point(25,100);
					points.push(point);
					var circle=new Circle(25,100);
					circles.push(circle);
					const canvas = document.getElementById('canvas');
					const context = canvas.getContext('2d');
					context.clearRect(0,0,canvas.width,canvas.height);
					for(var i=0; i<circles.length; i++) {
						var circle = circles[i];
						context.globalAlpha = 0.85;
						context.beginPath();
						context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
						context.fillStyle = circle.color;
						context.strokeStyle = "black";
						context.fill();
						context.stroke();
					}
					context.beginPath();
					context.lineWidth = 2;
					context.moveTo(points[0].x,points[0].y);
					for (var i = 0; i < points.length; i++) {
					context.lineTo(points[i].x, points[i].y);
					}
					context.lineTo(points[0].x, points[0].y);
					context.closePath();
					context.fillStyle="rgb(128,128,128)";
					context.fill();
					context.strokeStyle="black";
					context.stroke();
					for (var i = 0; i < 10; i++) {
						context.beginPath();
						context.lineWidth = 1;
						var xx = points[0].x + (points[points.length-1].x-points[0].x)*i/9;
						var yy = points[0].y + (points[points.length-1].y-points[0].y)*i/9;
						context.moveTo(xx,yy);
						context.lineTo(xx-7, yy+3);
						context.closePath();
						context.fillStyle="rgb(128,128,128)";
						context.fill();
						context.strokeStyle="black";
						context.stroke();
					}
				}
			</script>
			<button id="btn_set_6poi" type="button" class="btn btn-default" onclick="set_6poi()" style="float:left; font-size:10px;">
				<span class="glyphicon glyphicon-asterisk" style="font-size:10px">6 points</span>
			</button>
			<script type='text/javascript'>
				function set_6poi() {
					function Point(x, y) {
						this.x = x;
						this.y = y;
						}
						//圆圈对象
					function Circle(x, y) {
						this.x = x;
						this.y = y;
						this.radius = 5;
						this.color = "blue";
						//拖拽点的标记
						this.isSelected = false;
						}
					points = [];
					circles = [];
					var point=new Point(25,25);
					points.push(point);
					var circle=new Circle(25,25);
					circles.push(circle);
					var point=new Point(100,50);
					points.push(point);
					var circle=new Circle(100,50);
					circles.push(circle);
					var point=new Point(225,125);
					points.push(point);
					var circle=new Circle(225,125);
					circles.push(circle);
					var point=new Point(225,175);
					points.push(point);
					var circle=new Circle(225,175);
					circles.push(circle);
					var point=new Point(100,112);
					points.push(point);
					var circle=new Circle(100,112);
					circles.push(circle);
					var point=new Point(25,100);
					points.push(point);
					var circle=new Circle(25,100);
					circles.push(circle);
					const canvas = document.getElementById('canvas');
					const context = canvas.getContext('2d');
					context.clearRect(0,0,canvas.width,canvas.height);
					for(var i=0; i<circles.length; i++) {
						var circle = circles[i];
						context.globalAlpha = 0.85;
						context.beginPath();
						context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
						context.fillStyle = circle.color;
						context.strokeStyle = "black";
						context.fill();
						context.stroke();
					}
					context.beginPath();
					context.lineWidth = 2;
					context.moveTo(points[0].x,points[0].y);
					for (var i = 0; i < points.length; i++) {
					context.lineTo(points[i].x, points[i].y);
					}
					context.lineTo(points[0].x, points[0].y);
					context.closePath();
					context.fillStyle="rgb(128,128,128)";
					context.fill();
					context.strokeStyle="black";
					context.stroke();
					for (var i = 0; i < 10; i++) {
						context.beginPath();
						context.lineWidth = 1;
						var xx = points[0].x + (points[points.length-1].x-points[0].x)*i/9;
						var yy = points[0].y + (points[points.length-1].y-points[0].y)*i/9;
						context.moveTo(xx,yy);
						context.lineTo(xx-7, yy+3);
						context.closePath();
						context.fillStyle="rgb(128,128,128)";
						context.fill();
						context.strokeStyle="black";
						context.stroke();
					}
				}
			</script>
			
			<div style="background-color: transparent; width: 100%; height: 30pt;"></div>
			
			<span class="dragged" style="float:left; font-size:15px;">Drag to adjust the points.</span>
		</ul>
    </div>
	<div id="container" style="position:absolute; top:380px; left:20px; width:300px; height:500px; float:left; display:inline; padding-left:20px;">
	
	    <div class="form-group" id="l"></div>
		    <div class="col-sm-3"></div>
			
			    <span class="input-group-addon" style="font-size:15px; white-space:nowrap;">Subdivision Density
				<abbr title="Subdivision Density defines the density of the structural members. By increasing it, more members will be generated with a longer time cost.">(what's this?)</abbr></span>
				
				<div style="background-color: transparent; width: 100%; height: 0pt;"></div>
				
				<input type="range" min="0" max="1" step="0.01" name="reduce_rate" id="reduce_rate" style="width:240px; height:10px;" oninput="change_reduce_rate()" onchange="change_reduce_rate()"/>
			    <span id="value_reduce_rate" style="font-size:15px">0</span>
				<script type='text/javascript'>
					function change_reduce_rate() {
					    var value_reduce_rate = document.getElementById('reduce_rate').value;
						document.getElementById('value_reduce_rate').innerHTML = value_reduce_rate;
					}
				</script>
				<!-- <input type="text" class="form-control" name="reduce_rate" id="reduce_rate" style="width:400px; height:30px;"> -->
		
		<div class="form-group" id="l"></div>
		    <div class="col-sm-3"></div>
                <div class="col-sm-3"></div>
				<span class="input-group-addon" style="font-size:15px; white-space:nowrap;">Tolerance of Edge Length
				<abbr title="Tolerance of Edge Length defines the upper and lower bounds of the length constraint for each edge. Increasing it will give more freedom to the geometric generation process in graphic statics.">(what's this?)</abbr></span>
				
				<div style="background-color: transparent; width: 100%; height: 0pt;"></div>
				
				<input type="range" min="0" max="1" step="0.01" name="tolerance_of_edge_length" id="tolerance_of_edge_length" style="width:240px; height:10px;" oninput="change_tolerance_of_edge_length()" onchange="change_tolerance_of_edge_length()"/>
			    <span id="value_tolerance_of_edge_length" style="font-size:15px">0</span>
				<script type='text/javascript'>
					function change_tolerance_of_edge_length() {
					    var value_tolerance_of_edge_length = document.getElementById('tolerance_of_edge_length').value;
						document.getElementById('value_tolerance_of_edge_length').innerHTML = value_tolerance_of_edge_length;
					}
				</script>
			    <!-- <input type="text" class="form-control" name="tolerance_of_edge_length" id="tolerance_of_edge_length" style="width:400px; height:30px;"> -->
		
		<div class="form-group" id="l"></div>
		    <div class="col-sm-3"></div>
				<span id="length_constraint_maltiplier_spa" class="input-group-addon" style="font-size:15px; white-space:nowrap; display:none;">
				<abbr id="length_constraint_maltiplier_abb" title="Length Constraint Multiplier defines the relaxation of the edge length constraints. Increasing it will cause more rectangular cells than circular cells." style="display:none">LCM</abbr></span>
				<input type="range" min="0" max="2" step="0.01" name="length_constraint_maltiplier" id="length_constraint_maltiplier" style="width:200px; height:10px; display:none;" oninput="change_length_constraint_maltiplier()" onchange="change_length_constraint_maltiplier()"/>
			    <span id="value_length_constraint_maltiplier" style="font-size:15px; display:none">0</span>
				<script type='text/javascript'>
					function change_length_constraint_maltiplier() {
					    var value_length_constraint_maltiplier = document.getElementById('length_constraint_maltiplier').value;
						document.getElementById('value_length_constraint_maltiplier').innerHTML = value_length_constraint_maltiplier;
					}
				</script>
			    <!-- <input type="text" class="form-control" name="length_constraint_maltiplier" id="length_constraint_maltiplier" style="width:400px; height:30px;"> -->
        
				<div style="background-color: transparent; width: 100%; height: 0pt;"></div>
		
				<span id="boundary_constraint_magnitude_spa" class="input-group-addon" style="font-size:15px; white-space:nowrap; display:none;">
				<abbr id="boundary_constraint_magnitude_abb" title="Boundary Constraint Magnitude to define the magnitude of the boundary constraint to the form. Increasing it will make the structure attach closer to the boundary." style="display:none;">BCM</abbr></span>
				<input type="range" min="0" max="10" step="0.01" name="boundary_constraint_magnitude" id="boundary_constraint_magnitude" style="width:200px; height:10px; display:none;" oninput="change_boundary_constraint_magnitude()" onchange="change_boundary_constraint_magnitude()"/>
			    <span id="value_boundary_constraint_magnitude" style="font-size:15px; display:none;">0</span>
				<script type='text/javascript'>
					function change_boundary_constraint_magnitude() {
					    var value_boundary_constraint_magnitude = document.getElementById('boundary_constraint_magnitude').value;
						document.getElementById('value_boundary_constraint_magnitude').innerHTML = value_boundary_constraint_magnitude;
					}
				</script>
			    <!-- <input type="text" class="form-control" name="boundary_constraint_magnitude" id="boundary_constraint_magnitude" style="width:400px; height:30px;"> -->
        
				<div style="background-color: transparent; width: 100%; height: 0pt;"></div>
		
				<span id="perp_steps_spa" class="input-group-addon" style="font-size:15px; white-space:nowrap; display:none;">
				<abbr id="perp_steps_abb" title="Perp Steps defines the number of iterations in the geometric generation process in graphic statics. Increasing it will generate a more accurate structure but with a longer time." style="display:none;">PS</abbr></span>
				<input type="range" min="0" max="30000" step="1" name="perp_steps" id="perp_steps" style="width:200px; height:10px; display:none;" oninput="change_perp_steps()" onchange="change_perp_steps()"/>
			    <span id="value_perp_steps" style="font-size:15px; display:none;">0</span>
				<script type='text/javascript'>
					function change_perp_steps() {
					    var value_perp_steps = document.getElementById('perp_steps').value;
						document.getElementById('value_perp_steps').innerHTML = value_perp_steps;
					}
				</script>
			    <!-- <input type="text" class="form-control" name="perp_steps" id="perp_steps" style="width:400px; height:30px;"> -->
				
        <form class="form-horizontal" role="form">
            <div id="btn">
                <div class="col-sm-3"></div>
                <div class="input-group">
				
					<span class="input-group-btn">
					
					    <select id="model_select" style="display:none;">
						    <option value ="volvo">Dragonfly Wing Model</option>
						</select>
						
						<div style="background-color: transparent; width: 100%; height: 10pt;"></div>
						
						<button id="btn_showadv" type="button" class="btn btn-default" onclick="showadv()">
							<span class="glyphicon glyphicon-asterisk"></span>
							Show Advanced Options
						</button>
						<script type='text/javascript'>
							function showadv() {
								var obj = document.getElementById("value_perp_steps");
								obj.style.display = "inline";
								var obj = document.getElementById("perp_steps");
								obj.style.display = "inline";
								var obj = document.getElementById("perp_steps_abb");
								obj.style.display = "inline";
								var obj = document.getElementById("perp_steps_spa");
								obj.style.display = "inline";
								
								var obj = document.getElementById("value_boundary_constraint_magnitude");
								obj.style.display = "inline";
								var obj = document.getElementById("boundary_constraint_magnitude");
								obj.style.display = "inline";
								var obj = document.getElementById("boundary_constraint_magnitude_abb");
								obj.style.display = "inline";
								var obj = document.getElementById("boundary_constraint_magnitude_spa");
								obj.style.display = "inline";
								
								var obj = document.getElementById("value_length_constraint_maltiplier");
								obj.style.display = "inline";
								var obj = document.getElementById("length_constraint_maltiplier");
								obj.style.display = "inline";
								var obj = document.getElementById("length_constraint_maltiplier_abb");
								obj.style.display = "inline";
								var obj = document.getElementById("length_constraint_maltiplier_spa");
								obj.style.display = "inline";
								
								var obj = document.getElementById("model_select");
								obj.style.display = "inline";
								
								var obj = document.getElementById("btn_showadv");
								obj.style.display = "none";
							}
						</script>
						
						<div style="background-color: transparent; width: 100%; height: 10pt;"></div>
                        <!-- <span class="input-group-addon" style="font-size:15px; white-space:nowrap;">Click "Submit" bottom to proceed.</span> -->
                        
						<!-- <button id="btn_submit" type="button" class="btn btn-default" onclick="getInputs()"> -->
						<button id="btn_submit" type="button" class="btn btn-default" onclick="getInputs()">
                            <span class="glyphicon glyphicon-asterisk"></span>
                            Submit
                        </button>

						<button id="btn_setdefault" type="button" class="btn btn-default" onclick="set_default()">
                            <span class="glyphicon glyphicon-asterisk"></span>
                            Default Settings
                        </button>
						<script type='text/javascript'>
							function set_default() {
								document.getElementById("reduce_rate").value = 0.5;
								document.getElementById('value_reduce_rate').innerHTML = 0.5;
								document.getElementById("tolerance_of_edge_length").value = 0.3;
								document.getElementById('value_tolerance_of_edge_length').innerHTML = 0.3;
								document.getElementById("length_constraint_maltiplier").value = 0.5;
								document.getElementById('value_length_constraint_maltiplier').innerHTML = 0.5;
								document.getElementById("boundary_constraint_magnitude").value = 5;
								document.getElementById('value_boundary_constraint_magnitude').innerHTML = 5;
								document.getElementById("perp_steps").value = 10000;
								document.getElementById('value_perp_steps').innerHTML = 10000;
								function Point(x, y) {
									this.x = x;
									this.y = y;
									}
									//圆圈对象
								function Circle(x, y) {
									this.x = x;
									this.y = y;
									this.radius = 5;
									this.color = "blue";
									//拖拽点的标记
									this.isSelected = false;
									}
								points = [];
								circles = [];
								var point=new Point(25,25);
								points.push(point);
								var circle=new Circle(25,25);
								circles.push(circle);
								var point=new Point(225,125);
								points.push(point);
								var circle=new Circle(225,125);
								circles.push(circle);
								var point=new Point(225,175);
								points.push(point);
								var circle=new Circle(225,175);
								circles.push(circle);
								var point=new Point(100,112);
								points.push(point);
								var circle=new Circle(100,112);
								circles.push(circle);
								var point=new Point(25,100);
								points.push(point);
								var circle=new Circle(25,100);
								circles.push(circle);
								const canvas = document.getElementById('canvas');
								const context = canvas.getContext('2d');
								context.clearRect(0,0,canvas.width,canvas.height);
								for(var i=0; i<circles.length; i++) {
									var circle = circles[i];
									context.globalAlpha = 0.85;
									context.beginPath();
									context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
									context.fillStyle = circle.color;
									context.strokeStyle = "black";
									context.fill();
									context.stroke();
								}
								context.beginPath();
								context.lineWidth = 2;
								context.moveTo(points[0].x,points[0].y);
								for (var i = 0; i < points.length; i++) {
								context.lineTo(points[i].x, points[i].y);
								}
								context.lineTo(points[0].x, points[0].y);
								context.closePath();
								context.fillStyle="rgb(128,128,128)";
								context.fill();
								context.strokeStyle="black";
								context.stroke();
								for (var i = 0; i < 10; i++) {
									context.beginPath();
									context.lineWidth = 1;
									var xx = points[0].x + (points[points.length-1].x-points[0].x)*i/9;
									var yy = points[0].y + (points[points.length-1].y-points[0].y)*i/9;
									context.moveTo(xx,yy);
									context.lineTo(xx-7, yy+3);
									context.closePath();
									context.fillStyle="rgb(128,128,128)";
									context.fill();
									context.strokeStyle="black";
									context.stroke();
								}
							}
						</script>
                    </span>
                </div>
            </div>
            <div id="list">
                <!-- js动态新增 -->
            </div>
        </form>
    </div>
	
	<div id="container-item" style="position:absolute; top:150px; right:10px; width: 350px; display:block;">
	    <span class="glyphicon glyphicon-asterisk" style="font-size:20px; float:right;">Display Control Panel</span>
	</div>
	
	<div class="form-group" id="2"></div>
		<div class="col-sm-4"></div>
			<div id="container-item" style="position:absolute; top:185px; right:10px; width: 300px; float: right; display:block;">
				<ul class="tabs" data-tab>
				    <span class="dragged" style="float:right;">Change display mode.</span>
					<button id="btn_set_mink" type="button" class="btn btn-default" onclick="set_mink()" style="float:right;">
						<span class="glyphicon glyphicon-asterisk"></span>
						minkowski sum
					</button>
					<script type='text/javascript'>
						function set_mink() {
							display_mode = 2;
							draw_update();
						}
					</script>
					<button id="btn_set_normal" type="button" class="btn btn-default" onclick="set_normal()" style="float:right;">
						<span class="glyphicon glyphicon-asterisk"></span>
						normal
					</button>
					<script type='text/javascript'>
						function set_normal() {
							display_mode = 1;
							draw_update();
						}
					</script>
				</ul>
			</div>
	
	<div id="container" style="position:absolute; top:240px; right:10px; width:300px; height:500px; float:left; display:inline; padding-left:20px;">
		<div class="form-group" id="l"></div>
		    <div class="col-sm-4"></div>
			
			    <div style="background-color: transparent; width: 100%; height: 10pt;"></div>
				
				<select id="external_select" onchange="show_or_hode_external_forces(this)" style="float:right;">
					<option value ="a">Show External Forces</option>
					<option value ="b">Hide External Forces</option>
					<script type='text/javascript'>
						function show_or_hode_external_forces(obj) {
							//代表的是选中项的index索引
							var index = obj.selectedIndex;
							//代表的是选中项的的值
							var val = obj.options[index].value;
							//代表的是选中项的text
							var txt = obj.options[index].text;
							external_force_mode = 1 - index;
							draw_update();
						}
					</script>
				</select>
				
				<div style="background-color: transparent; width: 100%; height: 25pt;"></div>

				<span class="input-group-addon" style="font-size:15px; white-space:nowrap; float:right;">Minimum Radius&nbsp
			    <abbr style="float:right;" title="Minimum Radius defines the size of the smallest pipes in the normal display mode.">(what's this?)</abbr></span>				
				<input type="range" min="0" max="10" step="0.01" name="minumum_radius" id="minumum_radius" style="width:240px; height:23px; float:right;" oninput="input_minumum_radius()" onchange="change_minumum_radius()"/>
				<span id="value_minumum_radius" style="font-size:15px; float:right;">0</span>
				<script type='text/javascript'>
					function change_minumum_radius() {
					    var value_minumum_radius = document.getElementById('minumum_radius').value;
						document.getElementById('value_minumum_radius').innerHTML = value_minumum_radius;
					}
					function input_minumum_radius() {
					    var value_minumum_radius = document.getElementById('minumum_radius').value;
						document.getElementById('value_minumum_radius').innerHTML = value_minumum_radius;
						draw_update();
					}
				</script>
			    <!-- <input type="text" class="form-control" name="minumum_radius" id="minumum_radius" style="width:400px; height:30px;"> -->

				<div style="background-color: transparent; width: 100%; height: 20pt;"></div>

				<span class="input-group-addon" style="font-size:15px; white-space:nowrap; float:right;">Maximum Radius&nbsp
			    <abbr style="float:right;" title="Maximum Radius defines the size of the largest pipes in the normal display mode.">(what's this?)</abbr></span>
				<input type="range" min="0" max="100" step="0.01" name="maximum_radius" id="maximum_radius" style="width:240px; height:23px; float:right;" oninput="input_maximum_radius()" onchange="change_maximum_radius()"/>
			    <span id="value_maximum_radius" style="font-size:15px; float:right;">0</span>
				<script type='text/javascript'>
					function change_maximum_radius() {
					    var value_maximum_radius = document.getElementById('maximum_radius').value;
						document.getElementById('value_maximum_radius').innerHTML = value_maximum_radius;
					}
					function input_maximum_radius() {
					    var value_maximum_radius = document.getElementById('maximum_radius').value;
						document.getElementById('value_maximum_radius').innerHTML = value_maximum_radius;
						draw_update();
					}
				</script>
			    <!-- <input type="text" class="form-control" name="maximum_radius" id="maximum_radius" style="width:400px; height:30px;"> -->

				<div style="background-color: transparent; width: 100%; height: 20pt;"></div>

				<span class="input-group-addon" style="font-size:15px; white-space:nowrap; float:right;">Minkowski Sum Indicator&nbsp
			    <abbr style="float:right;" title="Minkowski Sum Indicator defines the form-to-force status in the minkowski sum display mode.">(what's this?)</abbr></span>
				<input type="range" min="0.01" max="0.99" step="0.01" name="minkowski_sum_indicator" id="minkowski_sum_indicator" style="width:240px; height:23px; float:right;" oninput="input_minkowski_sum_indicator()" onchange="change_minkowski_sum_indicator()"/>
			    <span id="value_minkowski_sum_indicator" style="font-size:15px; float:right;">0</span>
				<script type='text/javascript'>
					function change_minkowski_sum_indicator() {
					    var value_minkowski_sum_indicator = document.getElementById('minkowski_sum_indicator').value;
						document.getElementById('minkowski_sum_indicator').innerHTML = value_minkowski_sum_indicator;
					}
					function input_minkowski_sum_indicator() {
					    var value_minkowski_sum_indicator = document.getElementById('minkowski_sum_indicator').value;
						document.getElementById('value_minkowski_sum_indicator').innerHTML = value_minkowski_sum_indicator;
						draw_update();
					}
				</script>
				
    </div>
	
	<div id="container-item" style="position:absolute; top:470px; right:10px; width: 350px; display:block;">
	    <span class="glyphicon glyphicon-asterisk" style="font-size:20px; float:right;">File Manager</span>
	</div>
	<div id="container" style="position:absolute; top:490px; right:10px; width:288px; height:500px; float:right; display:inline; padding-left:20px;">
		<div class="form-group" id="l"></div>
		    <div class="col-sm-4"></div>
				<button id="btn_setdefault" type="button" class="btn btn-default" style="float:right;" onclick="download_stl()">
					<span class="glyphicon glyphicon-asterisk"></span>
					Export STL Model
				</button>
				<script type='text/javascript'>
				
					THREE.STLExporter = function () {};

					THREE.STLExporter.prototype = {

						constructor: THREE.STLExporter,

						parse: ( function () {

							var vector = new THREE.Vector3();
							var normalMatrixWorld = new THREE.Matrix3();

							return function ( scene ) {

								var output = '';

								output += 'solid exported\n';

								scene.traverse( function ( object ) {
									if ( object instanceof THREE.Mesh ) {

										// if object is hidden - exit
										if(object.visible == false) return; 

										var geometry = object.geometry;
										var matrixWorld = object.matrixWorld;
										var mesh = object;

										if(geometry instanceof THREE.BufferGeometry)
											geometry = new THREE.Geometry().fromBufferGeometry(geometry)

										if ( geometry instanceof THREE.Geometry) {

											var vertices = geometry.vertices;
											var faces = geometry.faces;
											
											normalMatrixWorld.getNormalMatrix( matrixWorld );

											if(typeof faces != 'undefined'){
												for ( var i = 0, l = faces.length; i < l; i ++ ) {
													var face = faces[ i ];

													vector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();

													output += '\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\n';
													output += '\t\touter loop\n';

													var indices = [ face.a, face.b, face.c ];

													for ( var j = 0; j < 3; j ++ ) {
														var vertexIndex = indices[ j ];
														if (typeof geometry.skinIndices !== 'undefined' && geometry.skinIndices.length == 0) {
															vector.copy( vertices[ vertexIndex ] ).applyMatrix4( matrixWorld );
															output += '\t\t\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\n';
														} else {
															vector.copy( vertices[ vertexIndex ] ); //.applyMatrix4( matrixWorld );
															
															// see https://github.com/mrdoob/three.js/issues/3187
															var boneIndices = [
																geometry.skinIndices[vertexIndex].x,
																geometry.skinIndices[vertexIndex].y,
																geometry.skinIndices[vertexIndex].z,
																geometry.skinIndices[vertexIndex].w
															];
															
															var weights = [
																geometry.skinWeights[vertexIndex].x,
																geometry.skinWeights[vertexIndex].y,
																geometry.skinWeights[vertexIndex].z,
																geometry.skinWeights[vertexIndex].w
															];
															
															var inverses = [
																skeleton.boneInverses[ boneIndices[0] ],
																skeleton.boneInverses[ boneIndices[1] ],
																skeleton.boneInverses[ boneIndices[2] ],
																skeleton.boneInverses[ boneIndices[3] ]
															];

															var skinMatrices = [
																skeleton.bones[ boneIndices[0] ].matrixWorld,
																skeleton.bones[ boneIndices[1] ].matrixWorld,
																skeleton.bones[ boneIndices[2] ].matrixWorld,
																skeleton.bones[ boneIndices[3] ].matrixWorld
															];

															//this checks to see if the mesh has any morphTargets - jc
															if (geometry.morphTargets !== 'undefined') {										
																var morphMatricesX = [];
																var morphMatricesY = [];
																var morphMatricesZ = [];
																var morphMatricesInfluence = [];

																for (var mt = 0; mt < geometry.morphTargets.length; mt++) {
																	//collect the needed vertex info - jc
																	morphMatricesX[mt] = geometry.morphTargets[mt].vertices[vertexIndex].x;
																	morphMatricesY[mt] = geometry.morphTargets[mt].vertices[vertexIndex].y;
																	morphMatricesZ[mt] = geometry.morphTargets[mt].vertices[vertexIndex].z;
																	morphMatricesInfluence[mt] = morphTargetInfluences[mt];
																}
															}
															
															var finalVector = new THREE.Vector4();

															if (mesh.geometry.morphTargets !== 'undefined') {

																var morphVector = new THREE.Vector4(vector.x, vector.y, vector.z);

																for (var mt = 0; mt < geometry.morphTargets.length; mt++) {
																	//not pretty, but it gets the job done - jc
																	morphVector.lerp(new THREE.Vector4(morphMatricesX[mt], morphMatricesY[mt], morphMatricesZ[mt], 1), morphMatricesInfluence[mt]);
																}

															}

															for (var k = 0; k < 4; k++) {

																var tempVector = new THREE.Vector4(vector.x, vector.y, vector.z);
																tempVector.multiplyScalar(weights[k]);
																//the inverse takes the vector into local bone space
																tempVector.applyMatrix4(inverses[k])
																//which is then transformed to the appropriate world space
																.applyMatrix4(skinMatrices[k]);
																finalVector.add(tempVector);

															}

															output += '\t\t\tvertex ' + finalVector.x + ' ' + finalVector.y + ' ' + finalVector.z + '\n';
														}
													}
													output += '\t\tendloop\n';
													output += '\tendfacet\n';
												}
											}
										}
									}

								} );

								output += 'endsolid exported\n';

								return output;
							};
						}() )
					};

					function download_stl() {
						var exporter = new THREE.STLExporter();
						if (display_mode==1) {
						    var temp_child_1 = scene.children[scene.children.length-1];
						    scene.remove(scene.children[scene.children.length-1]);
							var temp_child_2 = scene.children[scene.children.length-1];
						    scene.remove(scene.children[scene.children.length-1]);
							var temp_child_3 = scene.children[scene.children.length-1];
						    scene.remove(scene.children[scene.children.length-1]);
						}
						var stlString = exporter.parse(scene);
						console.log(stlString);
						var blob = new Blob( [stlString], { type : 'text/plain' } ); // Generate Blob from the string
						var link = document.createElement('a');
						link.style.display = 'none';
						document.body.appendChild(link);
						link.href = URL.createObjectURL(blob);
						link.download = 'output.stl';
						link.click();
						if (display_mode==1) {
							scene.add(temp_child_3);
							scene.add(temp_child_2);
							scene.add(temp_child_1); 
						}
						//window.open('../ghBackend/media/Default/output.stl')
					}
				</script>
	</div>			
				
	<div id="container" style="position:absolute; top:540px; right:10px; width:288px; height:500px; float:right; display:inline; padding-left:20px;">
		<div class="form-group" id="l"></div>
		    <div class="col-sm-4"></div>
				<button id="btn_setdefault" type="button" class="btn btn-default" style="float:right;" onclick="download_csv()">
					<span class="glyphicon glyphicon-asterisk"></span>
					Download Data File
				</button>
				<script type='text/javascript'>
				    function download_csv() {
						var element = document.createElement('a');
						element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
						element.setAttribute('download', 'output.csv');
						element.click();
					}
				</script>
	</div>
	
	<div id="container" style="position:absolute; top:590px; right:10px; width:288px; height:500px; float:right; display:inline; padding-left:20px;">
		<div class="form-group" id="upload1"></div>
		    <div class="col-sm-4"></div>
				<button id="btn_setdefault" type="button" class="btn btn-default" style="float:right;" onclick="upload_csv()">
					<span class="glyphicon glyphicon-asterisk"></span>
					Upload Data File
				</button>
				<script type='text/javascript'>
				    var localfileonload = false;
					
				    function upload_csv() {
						var input = document.createElement("input");
						input.type="file";
						var ran = Math.round(Math.random()*100000000).toString();
						input.id="files"+ran;
						input.style="display: none;";
						document.body.appendChild(input);
						document.getElementById('files'+ran).addEventListener('change', handleFileSelect, false);
					    //console.log(input);
						input.click();
					}
					
					function handleFileSelect(evt) {
					
					    localfileonload = true;
						
						var files = evt.target.files; // FileList object
						for (var i = 0, f; f = files[i]; i++) {
							var reader = new FileReader();
							reader.readAsText(f);
							reader.onload = (function () {
							
								//console.log(reader);
								//console.log(reader.result);
								
								form_pois = [];
								form_pois_neib_pois = [];
								form_pois_neib_edges = [];
								form_pois_edges = [];
								force_edges = [];
								force_edges_magnitude = [];
								
								geometry = [];
								minrad = document.getElementById('minumum_radius').value;
								maxrad = document.getElementById('maximum_radius').value;
								
								while(scene.children.length > 0){ 
									scene.remove(scene.children[0]); 
								}
								
								initLight();
								
								//辅助工具
								var helper = new THREE.AxesHelper(20);
								helper.position.x = -100;
								helper.position.z = -100;
								scene.add(helper);
								
								function deleteGroup(group) {
									//console.log(group);
									if (!group) return;
									// 删除掉所有的模型组内的mesh
									group.traverse(function (item) {
										if (item instanceof THREE.Mesh) {
											item.geometry.dispose(); // 删除几何体
											item.material.dispose(); // 删除材质
										}
									});
								}
								
								deleteGroup(group);
								deleteGroup(group_mink);
								deleteGroup(group_arrow);
								
								geometry = [];
								group = new THREE.Group();
								group_mink = new THREE.Group();
								group_arrow = new THREE.Group();
								minrad = document.getElementById('minumum_radius').value;
								maxrad = document.getElementById('maximum_radius').value;
								mink = document.getElementById("minkowski_sum_indicator").value;
								mat = new THREE.MeshLambertMaterial({color: 0x000000});
								
								console.log("local-file",minrad,maxrad);
								
								content = reader.result;
								arr_all = content.split('\r\n');
								arr = arr_all.slice(1,parseInt(arr_all[0])+1);
								if (display_mode==1) {
									for (var i = 0; i < arr.length; i++) {
										arr0 = arr[i].split(',');
										if (isNaN(arr0[4])==false) {
											//console.log(arr0);
											
											var p1 = new THREE.Vector3(arr0[0]-0, arr0[1]-0);
											var p2 = new THREE.Vector3(arr0[2]-0, arr0[3]-0);
											let line = new THREE.LineCurve3(p1,p2);
											var CurvePath = new THREE.CurvePath();
											CurvePath.curves.push(line);
											
											if (arr0[4]-0==-1) {
												var dir = new THREE.Vector3(((arr0[2]-0)-(arr0[0]-0))*0.07, 0, -((arr0[3]-0)-(arr0[1]-0))*0.07);
												var origin = new THREE.Vector3((arr0[0]-0)*0.07, 0, -(arr0[1]-0)*0.07);
												var length = 6;
												var colorstr = getColorCode(0,100,0);
												var arrowHelper = new THREE.ArrowHelper(dir, origin, length, colorstr, 1.0, 1.0);
												if (external_force_mode==1) {
													group_arrow.add(arrowHelper);
													geometry.push(arrowHelper);
												}
											} else {
												radius = arr0[4]*(maxrad-minrad)+minrad*1.0;
												
												if (arr0[4]-0<0.333) {
													var num1 = Math.round((c2[0]-c1[0])*(arr0[4]-0)/0.333+c1[0]);
													var num2 = Math.round((c2[1]-c1[1])*(arr0[4]-0)/0.333+c1[1]);
													var num3 = Math.round((c2[2]-c1[2])*(arr0[4]-0)/0.333+c1[2]);
													var colorstr = getColorCode(num1,num2,num3);
													var colormat = new THREE.MeshStandardMaterial({color: colorstr});
												} else if (arr0[4]-0<0.666) {
													var num1 = Math.round((c3[0]-c2[0])*(arr0[4]-0.333)/0.333+c2[0]);
													var num2 = Math.round((c3[1]-c2[1])*(arr0[4]-0.333)/0.333+c2[1]);
													var num3 = Math.round((c3[2]-c2[2])*(arr0[4]-0.333)/0.333+c2[2]);
													var colorstr = getColorCode(num1,num2,num3);
													var colormat = new THREE.MeshStandardMaterial({color: colorstr});
												} else {
													var num1 = Math.round((c4[0]-c3[0])*(arr0[4]-0.666)/0.333+c3[0]);
													var num2 = Math.round((c4[1]-c3[1])*(arr0[4]-0.666)/0.333+c3[1]);
													var num3 = Math.round((c4[2]-c3[2])*(arr0[4]-0.666)/0.333+c3[2]);
													var colorstr = getColorCode(num1,num2,num3);
													var colormat = new THREE.MeshStandardMaterial({color: colorstr});
												};

												var geometry_temp = new THREE.TubeGeometry(CurvePath, 8, radius, 8, false);
												var mesh = new THREE.Mesh(geometry_temp, colormat);
												mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
												mesh.scale.set(0.07, 0.07, 0.07); //缩放
												mesh.castShadow = true;
												group.add(mesh);
												geometry.push(geometry_temp);
												
												var geometry_temp = new THREE.SphereGeometry(radius, 8, 8);
												var mesh = new THREE.Mesh(geometry_temp, colormat);
												mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
												mesh.scale.set(0.07, 0.07, 0.07); //缩放
												mesh.position.x = arr0[0]*0.07;
												mesh.position.y = 0;
												mesh.position.z = -arr0[1]*0.07;
												mesh.castShadow = true;
												group.add(mesh);
												geometry.push(geometry_temp);
												
												var geometry_temp = new THREE.SphereGeometry(radius, 8, 8);
												var mesh = new THREE.Mesh(geometry_temp, colormat);
												mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
												mesh.scale.set(0.07, 0.07, 0.07); //缩放
												mesh.position.x = arr0[2]*0.07;
												mesh.position.y = 0;
												mesh.position.z = -arr0[3]*0.07;
												mesh.castShadow = true;
												group.add(mesh);
												geometry.push(geometry_temp);
											}
										}
									}
									//var loader = new THREE.STLLoader();
									//loader.load('../ghBackend/media/Default/output.stl', function (geometry) {
									//	//创建纹理
									//	var mat = new THREE.MeshLambertMaterial({color: 0x0079ED});
									//	var mesh = new THREE.Mesh(geometry, mat);
									//	mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
									//	mesh.scale.set(0.07, 0.07, 0.07); //缩放
									//	geometry.center(); //居中显示
									//	scene.add(mesh);
									//});
									var box3 = new THREE.Box3();
									// 计算层级模型group的包围盒
									// 模型group是加载一个三维模型返回的对象，包含多个网格模型
									box3.expandByObject(group);
									// 计算一个层级模型对应包围盒的几何体中心在世界坐标中的位置
									var center = new THREE.Vector3();
									box3.getCenter(center);
									// console.log('查看几何体中心坐标', center);
									// 重新设置模型的位置，使之居中。
									group.position.x = group.position.x - center.x;
									group.position.y = group.position.y - center.y;
									group.position.z = group.position.z - center.z;
									group_arrow.position.x = group_arrow.position.x - center.x;
									group_arrow.position.y = group_arrow.position.y - center.y;
									group_arrow.position.z = group_arrow.position.z - center.z;
									scene.add(group);
									scene.add(group_arrow);
									
									var plane = new THREE.PlaneGeometry(10000,10000);
									var colormat = new THREE.MeshStandardMaterial({color: "0xFCFCFC"});
									var mesh = new THREE.Mesh(plane, colormat);
									mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
									mesh.position.y = -30;
									mesh.receiveShadow = true;
									scene.add(mesh);
								}
								
								pnum = parseInt(arr_all[0])+1;
								pstep = parseInt(arr_all[pnum]);
								pnum = pnum + 1;
								arr = arr_all.slice(pnum,pnum+pstep);
								for (var i = 0; i < arr.length; i++) {
									arr0 = arr[i].split(',');
									var form_poi = new THREE.Vector3(arr0[0]-0, arr0[1]-0);
									form_pois.push(form_poi);
								}
								
								pnum = pnum + pstep;
								arr = arr_all.slice(pnum,pnum+pstep);
								for (var i = 0; i < arr.length; i++) {
									arr0 = arr[i].split(',');
									form_pois_neib_pois.push(arr0);
								}
								
								pnum = pnum + pstep;
								arr = arr_all.slice(pnum,pnum+pstep);
								for (var i = 0; i < arr.length; i++) {
									arr0 = arr[i].split(',');
									form_pois_neib_edges.push(arr0);
								}
								
								pnum = pnum + pstep;
								arr = arr_all.slice(pnum,pnum+pstep);
								for (var i = 0; i < arr.length; i++) {
									arr0 = arr[i].split(',');
									form_pois_edges.push(arr0);
								}
								
								pnum = pnum + pstep;
								pstep = parseInt(arr_all[pnum]);
								pnum = pnum + 1;
								arr = arr_all.slice(pnum,pnum+pstep);
								for (var i = 0; i < arr.length; i++) {
									arr0 = arr[i].split(',');
									var p1 = new THREE.Vector3(arr0[0]-0, arr0[1]-0);
									var p2 = new THREE.Vector3(arr0[2]-0, arr0[3]-0);
									let line_force = new THREE.LineCurve3(p1,p2);
									force_edges.push(line_force);
									force_edges_magnitude.push(arr0[4]-0);
								}
								
								if (display_mode==2) {
									let form_pois_edges_geos = [];
									for (var i = 0; i < form_pois_edges.length; i++) {
										arr0 = [];
										for (var j = 0; j < form_pois_edges[i].length; j++) {
											temp = force_edges[form_pois_edges[i][j]];
											var p1 = new THREE.Vector3(temp.v1.x*mink+form_pois[i].x*(1-mink),temp.v1.y*mink+form_pois[i].y*(1-mink));
											var p2 = new THREE.Vector3(temp.v2.x*mink+form_pois[i].x*(1-mink),temp.v2.y*mink+form_pois[i].y*(1-mink));
											temp = new THREE.LineCurve3(p1,p2);
											arr0.push(temp);
										}
										form_pois_edges_geos.push(arr0);
									}
									
									for (var i = 0; i < form_pois_neib_pois.length; i++) {
										for (var j = 0; j < form_pois_neib_pois[i].length; j++) {
										
											var rad_temp = force_edges_magnitude[form_pois_edges[i][j]];
											if (rad_temp-0==-1) {
												var colorstr = getColorCode(0,100,0);
												var colormat = new THREE.MeshStandardMaterial({color: colorstr});
											}else if (rad_temp-0<0.333) {
												var num1 = Math.round((c2[0]-c1[0])*(rad_temp-0)/0.333+c1[0]);
												var num2 = Math.round((c2[1]-c1[1])*(rad_temp-0)/0.333+c1[1]);
												var num3 = Math.round((c2[2]-c1[2])*(rad_temp-0)/0.333+c1[2]);
												var colorstr = getColorCode(num1,num2,num3);
												var colormat = new THREE.MeshStandardMaterial({color: colorstr});
											} else if (rad_temp-0<0.666) {
												var num1 = Math.round((c3[0]-c2[0])*(rad_temp-0.333)/0.333+c2[0]);
												var num2 = Math.round((c3[1]-c2[1])*(rad_temp-0.333)/0.333+c2[1]);
												var num3 = Math.round((c3[2]-c2[2])*(rad_temp-0.333)/0.333+c2[2]);
												var colorstr = getColorCode(num1,num2,num3);
												var colormat = new THREE.MeshStandardMaterial({color: colorstr});
											} else {
												var num1 = Math.round((c4[0]-c3[0])*(rad_temp-0.666)/0.333+c3[0]);
												var num2 = Math.round((c4[1]-c3[1])*(rad_temp-0.666)/0.333+c3[1]);
												var num3 = Math.round((c4[2]-c3[2])*(rad_temp-0.666)/0.333+c3[2]);
												var colorstr = getColorCode(num1,num2,num3);
												var colormat = new THREE.MeshStandardMaterial({color: colorstr});
											};
											
											let line1 = form_pois_edges_geos[i][j];
											let line2 = form_pois_edges_geos[form_pois_neib_pois[i][j]][form_pois_neib_edges[i][j]];
											var p1 = line1.v1; //顶点1坐标
											var p2 = line1.v2; //顶点2坐标
											var p3 = line2.v2; //顶点3坐标
											var p4 = line2.v1; //顶点4坐标
											var geo = new THREE.Geometry(); //声明一个空几何体对象
											geo.vertices.push(p1,p2,p3); //顶点坐标添加到geometry对象
											var normal = new THREE.Vector3( 0, 0, 1 ); //三角面法向量
											var face = new THREE.Face3( 0, 1, 2, normal); //创建三角面
											geo.faces.push(face); //三角面添加到几何体
											//var face = new THREE.Face3( 2, 3, 1, normal); //创建三角面
											var mesh = new THREE.Mesh(geo,colormat);//网格模型对象
											mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
											mesh.scale.set(0.07, 0.07, 0.07); //缩放
											mesh.castShadow = true;
											if (rad_temp-0==-1) {
												if (external_force_mode==1) {
													group_mink.add(mesh);
												}
											} else {
												group_mink.add(mesh);
											}
											var geo = new THREE.Geometry(); //声明一个空几何体对象
											geo.vertices.push(p3,p4,p1); //顶点坐标添加到geometry对象
											var normal = new THREE.Vector3( 0, 0, 1 ); //三角面法向量
											var face = new THREE.Face3( 0, 1, 2, normal); //创建三角面
											geo.faces.push(face); //三角面添加到几何体
											//var face = new THREE.Face3( 2, 3, 1, normal); //创建三角面
											var mesh = new THREE.Mesh(geo,colormat);//网格模型对象
											mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
											mesh.scale.set(0.07, 0.07, 0.07); //缩放
											mesh.castShadow = true;
											if (rad_temp-0==-1) {
												if (external_force_mode==1) {
													group_mink.add(mesh);
												}
											} else {
												group_mink.add(mesh);
											}
										}
									}
									var box3 = new THREE.Box3();
									// 计算层级模型group的包围盒
									// 模型group是加载一个三维模型返回的对象，包含多个网格模型
									box3.expandByObject(group_mink);
									// 计算一个层级模型对应包围盒的几何体中心在世界坐标中的位置
									var center = new THREE.Vector3();
									box3.getCenter(center);
									// console.log('查看几何体中心坐标', center);
									// 重新设置模型的位置，使之居中。
									group_mink.position.x = group_mink.position.x - center.x;
									group_mink.position.y = group_mink.position.y - center.y;
									group_mink.position.z = group_mink.position.z - center.z;
									scene.add(group_mink);
								}
								
								pnum = pnum + pstep;
								pstep = 6;
								arr_input = arr_all.slice(pnum,pnum+pstep);
								
								document.getElementById("reduce_rate").defaultValue = arr_input[1];
								document.getElementById('value_reduce_rate').innerHTML = arr_input[1];
								document.getElementById("tolerance_of_edge_length").defaultValue = arr_input[2];
								document.getElementById('value_tolerance_of_edge_length').innerHTML = arr_input[2];
								document.getElementById("length_constraint_maltiplier").defaultValue = arr_input[3];
								document.getElementById('value_length_constraint_maltiplier').innerHTML = arr_input[3];
								document.getElementById("boundary_constraint_magnitude").defaultValue = arr_input[4];
								document.getElementById('value_boundary_constraint_magnitude').innerHTML = arr_input[4];
								document.getElementById("perp_steps").defaultValue = arr_input[5];
								document.getElementById('value_perp_steps').innerHTML = arr_input[5];
								
								arr0_input = arr_input[0].split(',');
								function Point(x, y) {
									this.x = x;
									this.y = y;
									}
									//圆圈对象
								function Circle(x, y) {
									this.x = x;
									this.y = y;
									this.radius = 5;
									this.color = "blue";
									//拖拽点的标记
									this.isSelected = false;
									}
								points = [];
								circles = [];
								for (var i = 0; i < arr0_input.length/2; i++) {
									var point=new Point((arr0_input[i*2]-0)/2,(500-arr0_input[i*2+1])/2);
									points.push(point);
									var circle=new Circle((arr0_input[i*2]-0)/2,(500-arr0_input[i*2+1])/2);
									circles.push(circle);
								}
								
								wall_info = [];
								wall_info.push((arr0_input[0]-0)/500*3000*0.07);
								wall_info.push((arr0_input[1]-0)/500*3000*0.07);
								wall_info.push((arr0_input[arr0_input.length-2]-0)/500*3000*0.07);
								wall_info.push((arr0_input[arr0_input.length-1]-0)/500*3000*0.07);
								
								if (display_mode==1) {
								    var vec = new THREE.Vector3(wall_info[3]-wall_info[1], -(wall_info[2]-wall_info[0]));
									vec = vec.normalize();
									var baseShape = new THREE.Shape();
									baseShape.moveTo(wall_info[0], wall_info[1]);
									baseShape.lineTo(wall_info[2], wall_info[3]);
									baseShape.lineTo(wall_info[2]+vec.x*3, wall_info[3]+vec.y*3);
									baseShape.lineTo(wall_info[0]+vec.x*3, wall_info[1]+vec.y*3);
									baseShape.lineTo(wall_info[0], wall_info[1]);
									var extrudedGeometry = new THREE.ExtrudeGeometry(baseShape, {amount: 20, bevelEnabled: false});
									var tmaterial = new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:0.8});
									//tmaterial.opacity = 0.1;
									var extrudedMesh = new THREE.Mesh(extrudedGeometry, tmaterial);
									extrudedMesh.rotation.x = -0.5 * Math.PI; //将模型摆正
									extrudedMesh.position.x = extrudedMesh.position.x - center.x;
									extrudedMesh.position.y = extrudedMesh.position.y - center.y -10;
									extrudedMesh.position.z = extrudedMesh.position.z - center.z;
									scene.add(extrudedMesh);
								}

								const canvas = document.getElementById('canvas');
								const context = canvas.getContext('2d');
								context.clearRect(0,0,canvas.width,canvas.height);
								for(var i=0; i<circles.length; i++) {
									var circle = circles[i];
									context.globalAlpha = 0.85;
									context.beginPath();
									context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
									context.fillStyle = circle.color;
									context.strokeStyle = "black";
									context.fill();
									context.stroke();
								}
								context.beginPath();
								context.lineWidth = 2;
								context.moveTo(points[0].x,points[0].y);
								for (var i = 0; i < points.length; i++) {
								context.lineTo(points[i].x, points[i].y);
								}
								context.lineTo(points[0].x, points[0].y);
								context.closePath();
								context.fillStyle="rgb(128,128,128)";
								context.fill();
								context.strokeStyle="black";
								context.stroke();
								for (var i = 0; i < 10; i++) {
									context.beginPath();
									context.lineWidth = 1;
									var xx = points[0].x + (points[points.length-1].x-points[0].x)*i/9;
									var yy = points[0].y + (points[points.length-1].y-points[0].y)*i/9;
									context.moveTo(xx,yy);
									context.lineTo(xx-7, yy+3);
									context.closePath();
									context.fillStyle="rgb(128,128,128)";
									context.fill();
									context.strokeStyle="black";
									context.stroke();
								}
								
								animate();
								window.onresize = onWindowResize;
								
								var oldnode = document.getElementById("loading");
								if (oldnode!=null) {
								    oldnode.parentNode.removeChild(oldnode);
								}
								
							})
						}
					}
				</script>
	</div>
				
	<img id="loading" src="loading.gif" width="287" height="141" style="position:absolute; top:300px; left:600px; display:block;">
	
	<img id="PSL" src="PSL.png" width="150" height="105" style="position:absolute; top:20px; right:10px; display:block;">
	
	<script>
	
	    let wall_info;

		var content_input;
		var textfile_input;
		let arr_input;
		let arr0_input;
		//线段的点的集合
		var points=[];
		//可拖动圆圈的点的集合
		var circles=[];
		if (window.XMLHttpRequest)
		{ 
			textfile_input = new XMLHttpRequest(); 
		}
		textfile_input.onreadystatechange = function ()
		{   
		
			if (textfile_input.readyState == 4 && textfile_input.status == 200)
			{ 
				content_input = textfile_input.responseText;
				arr_input = content_input.split('\r\n');
				// document.getElementById("reduce_rate").defaultValue = "0.5";
				// document.getElementById("tolerance_of_edge_length").defaultValue = "0.3";
				// document.getElementById("length_constraint_maltiplier").defaultValue = "0.5";
				// document.getElementById("boundary_constraint_magnitude").defaultValue = "5";
				// document.getElementById("perp_steps").defaultValue = "10000";
				// document.getElementById("minumum_radius").defaultValue = "1";
				// document.getElementById("maximum_radius").defaultValue = "10";
				document.getElementById("reduce_rate").defaultValue = arr_input[1];
				document.getElementById('value_reduce_rate').innerHTML = arr_input[1];
				document.getElementById("tolerance_of_edge_length").defaultValue = arr_input[2];
				document.getElementById('value_tolerance_of_edge_length').innerHTML = arr_input[2];
				document.getElementById("length_constraint_maltiplier").defaultValue = arr_input[3];
				document.getElementById('value_length_constraint_maltiplier').innerHTML = arr_input[3];
				document.getElementById("boundary_constraint_magnitude").defaultValue = arr_input[4];
				document.getElementById('value_boundary_constraint_magnitude').innerHTML = arr_input[4];
				document.getElementById("perp_steps").defaultValue = arr_input[5];
				document.getElementById('value_perp_steps').innerHTML = arr_input[5];
				document.getElementById("minumum_radius").defaultValue = 2;
				document.getElementById('value_minumum_radius').innerHTML = 2;
				document.getElementById("maximum_radius").defaultValue = 20;
				document.getElementById('value_maximum_radius').innerHTML = 20;
				document.getElementById('value_minkowski_sum_indicator').innerHTML = 0.5;
				document.getElementById('minkowski_sum_indicator').defaultValue = 0.5;
				arr0_input = arr_input[0].split(', ');
				arr0_input[0] = arr0_input[0].split('[')[1];
				arr0_input[arr0_input.length-1] = arr0_input[arr0_input.length-1].split(']')[0];
				console.log(arr0_input);
				//每一个点的对象
				// var point=new Point(50,50);
				// points.push(point);
				// var point=new Point(450,250);
				// points.push(point);
				// var point=new Point(450,350);
				// points.push(point);
				// var point=new Point(200,225);
				// points.push(point);
				// var point=new Point(50,200);
				// points.push(point);
				// var circle=new Circle(50,50);
				// circles.push(circle);
				// var circle=new Circle(450,250);
				// circles.push(circle);
				// var circle=new Circle(450,350);
				// circles.push(circle);
				// var circle=new Circle(200,225);
				// circles.push(circle);
				// var circle=new Circle(50,200);
				// circles.push(circle);
				for (var i = 0; i < arr0_input.length/2; i++) {
					var point=new Point((arr0_input[i*2]-0)/2,(500-arr0_input[i*2+1])/2);
					points.push(point);
					var circle=new Circle((arr0_input[i*2]-0)/2,(500-arr0_input[i*2+1])/2);
					circles.push(circle);
				}
				
				wall_info = [];
				wall_info.push((arr0_input[0]-0)/500*3000*0.07);
				wall_info.push((arr0_input[1]-0)/500*3000*0.07);
				wall_info.push((arr0_input[arr0_input.length-2]-0)/500*3000*0.07);
				wall_info.push((arr0_input[arr0_input.length-1]-0)/500*3000*0.07);

				const canvas = document.getElementById('canvas');
				const context = canvas.getContext('2d');

				var isDragging=false
				function Point(x, y) {
				this.x = x;
				this.y = y;
				}
				//圆圈对象
				function Circle(x, y) {
				this.x = x;
				this.y = y;
				this.radius = 5;
				this.color = "blue";
				//拖拽点的标记
				this.isSelected = false;
				}

				//进入下面的代码，绘制点
				context.clearRect(0,0,canvas.width,canvas.height);
				//遍历数组画圆
				circles[0].color="blue";
				for(var i=0; i<circles.length; i++) {
				var circle = circles[i];
				// 绘制圆圈
				context.globalAlpha = 0.85;
				context.beginPath();
				context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
				context.fillStyle = circle.color;
				context.strokeStyle = "black";
				context.fill();
				context.stroke();
				}
				// 画线
				//从起始点开始绘制
				context.beginPath();
				context.lineWidth = 2;
				context.moveTo(points[0].x,points[0].y);
				for (var i = 0; i < points.length; i++) {
				context.lineTo(points[i].x, points[i].y);
				}
				context.lineTo(points[0].x, points[0].y);
				context.closePath();
				context.fillStyle="rgb(128,128,128)";
				context.fill();
				context.strokeStyle="black";
				context.stroke();
				for (var i = 0; i < 10; i++) {
					context.beginPath();
					context.lineWidth = 1;
					var xx = points[0].x + (points[points.length-1].x-points[0].x)*i/9;
					var yy = points[0].y + (points[points.length-1].y-points[0].y)*i/9;
					context.moveTo(xx,yy);
					context.lineTo(xx-7, yy+3);
					context.closePath();
					context.fillStyle="rgb(128,128,128)";
					context.fill();
					context.strokeStyle="black";
					context.stroke();
				}

				canvas.onmousedown=function(e){
				var clickX = e.pageX - canvas.offsetLeft-40;
				var clickY = e.pageY - canvas.offsetTop-130;
				console.log("mouse click revised: ",clickX,clickY);
				//判断当前点击点是否在已经绘制的圆圈上，如果是执行相关操作，并return，不进入画线的代码
				for(var i=0; i<circles.length; i++) {
					var circle = circles[i];
					//使用勾股定理计算这个点与圆心之间的距离
					var distanceFromCenter = Math.sqrt(Math.pow(circle.x - clickX, 2) + Math.pow(circle.y - clickY, 2));
					// 如果是其他的点，则设置可以拖动
					if (distanceFromCenter <= circle.radius) {
						// 清除之前选择的圆圈
						index=i;
						isDragging=true;
						//停止搜索
						return;
					}
				}
				};

				canvas.onmousemove=function(e){
				// 判断圆圈是否开始拖拽
				if (isDragging == true) {
					// 判断拖拽对象是否存在
					// 取得鼠标位置
					var x1 = e.pageX - canvas.offsetLeft-40;
					var y1 = e.pageY - canvas.offsetTop-130;
					context.clearRect(0,0,canvas.width,canvas.height);
					//根据上文得到的index设置index点位置随鼠标改变
					circles[index].x=x1;
					circles[index].y=y1;
					points[index].x=x1;
					points[index].y=y1;
					for(var i=0; i<circles.length; i++) {
						var circle = circles[i];
						// 绘制圆圈
						context.globalAlpha = 0.85;
						context.beginPath();
						context.arc(circle.x, circle.y, circle.radius, 0, Math.PI*2);
						context.fillStyle = circle.color;
						context.strokeStyle = "black";
						context.fill();
						context.stroke();
					}
					context.beginPath();
					context.lineWidth = 2;
					context.moveTo(points[0].x,points[0].y);
					for (var i = 0; i < points.length; i++) {
					context.lineTo(points[i].x, points[i].y);
					}
					context.lineTo(points[0].x, points[0].y);
					context.closePath();
					context.fillStyle="rgb(128,128,128)";
					context.fill();
					context.strokeStyle="black";
					context.stroke();
					for (var i = 0; i < 10; i++) {
						context.beginPath();
						context.lineWidth = 1;
						var xx = points[0].x + (points[points.length-1].x-points[0].x)*i/9;
						var yy = points[0].y + (points[points.length-1].y-points[0].y)*i/9;
						context.moveTo(xx,yy);
						context.lineTo(xx-7, yy+3);
						context.closePath();
						context.fillStyle="rgb(128,128,128)";
						context.fill();
						context.strokeStyle="black";
						context.stroke();
					}
				}
				};

				canvas.onmouseup=function(){
				isDragging=false;
				};

				canvas.onmouseout=function(){
				isDragging=false;
				};
			}
		}
		var ran = Math.round(Math.random()*100000000).toString();
		textfile_input.open("GET", '../ghBackend/media/Default/input.txt'+'?'+ran, true);
		textfile_input.send();

	</script>

	<script>
	    
		var mink = document.getElementById("minkowski_sum_indicator").value;
		
		var display_mode = 1;
		var external_force_mode = 1;
		
		let c1 = [90,135,175];
		let c2 = [55,110,155];
		let c3 = [5,65,110];
		let c4 = [15,50,80];
		
		let form_pois = [];
		let form_pois_neib_pois = [];
		let form_pois_neib_edges = [];
		let form_pois_edges = [];
		let force_edges = [];
		let force_edges_magnitude = [];
		
		let arr;
		let arr_all;
		let arr0;
		var geometry = [];
		var radius;
		var pnum;
		var pstep;
		var minrad;
		var maxrad;
		var mat = new THREE.MeshLambertMaterial({color: 0x000000});
		
		function getColorCode(r,g,b){
			var c="#";
			c+=r.toString(16).length==1?"0"+r.toString(16):r.toString(16);
			c+=g.toString(16).length==1?"0"+g.toString(16):g.toString(16);
			c+=b.toString(16).length==1?"0"+b.toString(16):b.toString(16);
			return c;
		}
	
		var renderer;
		function initRender() {
			renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
			renderer.setSize(window.innerWidth,window.innerHeight);
			//告诉渲染器需要阴影效果
			renderer.shadowMap.enabled = true;
			renderer.setClearColor(0xFCFCFC);
			document.body.appendChild(renderer.domElement);
			document.body.style.backgroundColor = '#FCFCFC';
		}

		var camera;
		function initCamera() {
			camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000);
			camera.position.set(0, 100, 100);
			camera.lookAt(new THREE.Vector3(0,0,0));
		}

		var scene;
		function initScene() {
			scene = new THREE.Scene();
		}

		function initLight() {
		
			scene.add(new THREE.AmbientLight(0x444444));
			
			//var light = new THREE.DirectionalLight(0xffffff, 2);
			//light.position = new THREE.Vector3(140, 200, 140);

			var light = new THREE.PointLight(0xffffff,2.0,0,1);
			light.position.set(-140,50,140);
			//light.intensity = 1.5;

			//告诉平行光需要开启阴影投射
			light.castShadow = true;

			scene.add(light);
			
		}
			
		//初始化性能插件
			
		var stats;
		function initStats() {
			stats = new Stats();
			//document.body.appendChild(stats.dom);
		}

		//用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放
		var controls;
		function initControls() {

			controls = new THREE.OrbitControls( camera, renderer.domElement );

			// 如果使用animate方法时，将此函数删除
			//controls.addEventListener( 'change', render );
			// 使动画循环使用时阻尼或自转 意思是否有惯性
			controls.enableDamping = false;
			//动态阻尼系数 就是鼠标拖拽旋转灵敏度
			controls.dampingFactor = 0.1;
			//是否可以缩放
			controls.enableZoom = true;
			//是否自动旋转
			controls.autoRotate = false;
			controls.autoRotateSpeed = 0.5;
			//设置相机距离原点的最远距离
			controls.minDistance  = 1;
			//设置相机距离原点的最远距离
			controls.maxDistance  = 1000;
			//是否开启右键拖拽
			controls.enablePan = true;
		}

		function render() {
			
			//console.log(scene)
			//console.log(camera)

			renderer.render( scene, camera );		
			
		}

		//窗口变动触发的函数
		function onWindowResize() {

			camera.aspect = window.innerWidth/window.innerHeight;
			camera.updateProjectionMatrix();
			render();
			renderer.setSize(window.innerWidth,window.innerHeight);

		}

		function animate() {
		
			//更新控制器
			render();

			//更新性能插件
			stats.update();

			controls.update();
			
			requestAnimationFrame(animate);
			
		}
		
		initRender();
		
		
		initScene();
		initCamera();
		initControls();
		initStats();
		
		initLight();

		//辅助工具
		var helper = new THREE.AxesHelper(20);
		helper.position.x = -100;
		helper.position.z = -100;
		scene.add(helper);
		
		var group = new THREE.Group();
		var group_mink = new THREE.Group();
		var group_arrow = new THREE.Group();
		
		var content;
		var textfile;
		
		if (window.XMLHttpRequest)
			{ 
				textfile = new XMLHttpRequest(); 
			}
		
		var ran = Math.round(Math.random()*100000000).toString();
		textfile.open("GET", '../ghBackend/media/Default/output.csv'+'?'+ran, true);
		textfile.send();
		
		setTimeout(function(){
			if (textfile.readyState != 4 || textfile.status != 200) {
			    if (localfileonload==false){ 
					console.log("10 second to auto fresh the web page");
					location.reload(true) //refresh the web page
				}
			}
		},10000);
		
		textfile.onreadystatechange = function ()
		{   

			if (textfile.readyState == 4 && textfile.status == 200)
			{ 

				minrad = document.getElementById('minumum_radius').value;
				maxrad = document.getElementById('maximum_radius').value;
				console.log("draw",minrad,maxrad);
				
				content = textfile.responseText;
				arr_all = content.split('\r\n');
				arr = arr_all.slice(1,parseInt(arr_all[0])+1);
				if (display_mode==1) {
					for (var i = 0; i < arr.length; i++) {
						arr0 = arr[i].split(',');
						if (isNaN(arr0[4])==false) {
							//console.log(arr0);
							
							var p1 = new THREE.Vector3(arr0[0]-0, arr0[1]-0);
							var p2 = new THREE.Vector3(arr0[2]-0, arr0[3]-0);
							let line = new THREE.LineCurve3(p1,p2);
							var CurvePath = new THREE.CurvePath();
							CurvePath.curves.push(line);
							
							if (arr0[4]-0==-1) {
								var dir = new THREE.Vector3(((arr0[2]-0)-(arr0[0]-0))*0.07, 0, -((arr0[3]-0)-(arr0[1]-0))*0.07);
								var origin = new THREE.Vector3((arr0[0]-0)*0.07, 0, -(arr0[1]-0)*0.07);
								var length = 6;
								var colorstr = getColorCode(0,100,0);
								var arrowHelper = new THREE.ArrowHelper(dir, origin, length, colorstr, 1.0, 1.0);
								if (external_force_mode==1) {
									group_arrow.add(arrowHelper);
									geometry.push(arrowHelper);
								}
							} else {
								radius = arr0[4]*(maxrad-minrad)+minrad*1.0;
								
								if (arr0[4]-0<0.333) {
									var num1 = Math.round((c2[0]-c1[0])*(arr0[4]-0)/0.333+c1[0]);
									var num2 = Math.round((c2[1]-c1[1])*(arr0[4]-0)/0.333+c1[1]);
									var num3 = Math.round((c2[2]-c1[2])*(arr0[4]-0)/0.333+c1[2]);
									var colorstr = getColorCode(num1,num2,num3);
									var colormat = new THREE.MeshStandardMaterial({color: colorstr});
								} else if (arr0[4]-0<0.666) {
									var num1 = Math.round((c3[0]-c2[0])*(arr0[4]-0.333)/0.333+c2[0]);
									var num2 = Math.round((c3[1]-c2[1])*(arr0[4]-0.333)/0.333+c2[1]);
									var num3 = Math.round((c3[2]-c2[2])*(arr0[4]-0.333)/0.333+c2[2]);
									var colorstr = getColorCode(num1,num2,num3);
									var colormat = new THREE.MeshStandardMaterial({color: colorstr});
								} else {
									var num1 = Math.round((c4[0]-c3[0])*(arr0[4]-0.666)/0.333+c3[0]);
									var num2 = Math.round((c4[1]-c3[1])*(arr0[4]-0.666)/0.333+c3[1]);
									var num3 = Math.round((c4[2]-c3[2])*(arr0[4]-0.666)/0.333+c3[2]);
									var colorstr = getColorCode(num1,num2,num3);
									var colormat = new THREE.MeshStandardMaterial({color: colorstr});
								};

								var geometry_temp = new THREE.TubeGeometry(CurvePath, 8, radius, 8, false);
								var mesh = new THREE.Mesh(geometry_temp, colormat);
								mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
								mesh.scale.set(0.07, 0.07, 0.07); //缩放
								mesh.castShadow = true;
								group.add(mesh);
								geometry.push(geometry_temp);
								
								var geometry_temp = new THREE.SphereGeometry(radius, 8, 8);
								var mesh = new THREE.Mesh(geometry_temp, colormat);
								mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
								mesh.scale.set(0.07, 0.07, 0.07); //缩放
								mesh.position.x = arr0[0]*0.07;
								mesh.position.y = 0;
								mesh.position.z = -arr0[1]*0.07;
								mesh.castShadow = true;
								group.add(mesh);
								geometry.push(geometry_temp);
								
								var geometry_temp = new THREE.SphereGeometry(radius, 8, 8);
								var mesh = new THREE.Mesh(geometry_temp, colormat);
								mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
								mesh.scale.set(0.07, 0.07, 0.07); //缩放
								mesh.position.x = arr0[2]*0.07;
								mesh.position.y = 0;
								mesh.position.z = -arr0[3]*0.07;
								mesh.castShadow = true;
								group.add(mesh);
								geometry.push(geometry_temp);
							}
						}
					}
					//var loader = new THREE.STLLoader();
					//loader.load('../ghBackend/media/Default/output.stl', function (geometry) {
					//	//创建纹理
					//	var mat = new THREE.MeshLambertMaterial({color: 0x0079ED});
					//	var mesh = new THREE.Mesh(geometry, mat);
					//	mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
					//	mesh.scale.set(0.07, 0.07, 0.07); //缩放
					//	geometry.center(); //居中显示
					//	scene.add(mesh);
					//});
					var box3 = new THREE.Box3();
					// 计算层级模型group的包围盒
					// 模型group是加载一个三维模型返回的对象，包含多个网格模型
					box3.expandByObject(group);
					// 计算一个层级模型对应包围盒的几何体中心在世界坐标中的位置
					var center = new THREE.Vector3();
					box3.getCenter(center);
					// console.log('查看几何体中心坐标', center);
					// 重新设置模型的位置，使之居中。
					group.position.x = group.position.x - center.x;
					group.position.y = group.position.y - center.y;
					group.position.z = group.position.z - center.z;
					group_arrow.position.x = group_arrow.position.x - center.x;
					group_arrow.position.y = group_arrow.position.y - center.y;
					group_arrow.position.z = group_arrow.position.z - center.z;
					scene.add(group);
					scene.add(group_arrow);
					
					var plane = new THREE.PlaneGeometry(10000,10000);
					var colormat = new THREE.MeshStandardMaterial({color: "0xFCFCFC"});
					var mesh = new THREE.Mesh(plane, colormat);
					mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
					mesh.position.y = -30;
					mesh.receiveShadow = true;
					scene.add(mesh);		
				}
				
				pnum = parseInt(arr_all[0])+1;
				pstep = parseInt(arr_all[pnum]);
				pnum = pnum + 1;
				arr = arr_all.slice(pnum,pnum+pstep);
				for (var i = 0; i < arr.length; i++) {
					arr0 = arr[i].split(',');
					var form_poi = new THREE.Vector3(arr0[0]-0, arr0[1]-0);
					form_pois.push(form_poi);
				}
				
				pnum = pnum + pstep;
				arr = arr_all.slice(pnum,pnum+pstep);
				for (var i = 0; i < arr.length; i++) {
					arr0 = arr[i].split(',');
					form_pois_neib_pois.push(arr0);
				}
				
				pnum = pnum + pstep;
				arr = arr_all.slice(pnum,pnum+pstep);
				for (var i = 0; i < arr.length; i++) {
					arr0 = arr[i].split(',');
					form_pois_neib_edges.push(arr0);
				}
				
				pnum = pnum + pstep;
				arr = arr_all.slice(pnum,pnum+pstep);
				for (var i = 0; i < arr.length; i++) {
					arr0 = arr[i].split(',');
					form_pois_edges.push(arr0);
				}
				
				pnum = pnum + pstep;
				pstep = parseInt(arr_all[pnum]);
				pnum = pnum + 1;
				arr = arr_all.slice(pnum,pnum+pstep);
				for (var i = 0; i < arr.length; i++) {
					arr0 = arr[i].split(',');
					var p1 = new THREE.Vector3(arr0[0]-0, arr0[1]-0);
					var p2 = new THREE.Vector3(arr0[2]-0, arr0[3]-0);
					let line_force = new THREE.LineCurve3(p1,p2);
					force_edges.push(line_force);
					force_edges_magnitude.push(arr0[4]-0);
				}
				
				if (display_mode==2) {
					let form_pois_edges_geos = [];
					for (var i = 0; i < form_pois_edges.length; i++) {
						arr0 = [];
						for (var j = 0; j < form_pois_edges[i].length; j++) {
							temp = force_edges[form_pois_edges[i][j]];
							var p1 = new THREE.Vector3(temp.v1.x*mink+form_pois[i].x*(1-mink),temp.v1.y*mink+form_pois[i].y*(1-mink));
							var p2 = new THREE.Vector3(temp.v2.x*mink+form_pois[i].x*(1-mink),temp.v2.y*mink+form_pois[i].y*(1-mink));
							temp = new THREE.LineCurve3(p1,p2);
							arr0.push(temp);
						}
						form_pois_edges_geos.push(arr0);
					}
					
					for (var i = 0; i < form_pois_neib_pois.length; i++) {
						for (var j = 0; j < form_pois_neib_pois[i].length; j++) {
						
							var rad_temp = force_edges_magnitude[form_pois_edges[i][j]];
							if (rad_temp-0==-1) {
							    var colorstr = getColorCode(0,100,0);
								var colormat = new THREE.MeshStandardMaterial({color: colorstr});
							}else if (rad_temp-0<0.333) {
								var num1 = Math.round((c2[0]-c1[0])*(rad_temp-0)/0.333+c1[0]);
								var num2 = Math.round((c2[1]-c1[1])*(rad_temp-0)/0.333+c1[1]);
								var num3 = Math.round((c2[2]-c1[2])*(rad_temp-0)/0.333+c1[2]);
								var colorstr = getColorCode(num1,num2,num3);
								var colormat = new THREE.MeshStandardMaterial({color: colorstr});
							} else if (rad_temp-0<0.666) {
								var num1 = Math.round((c3[0]-c2[0])*(rad_temp-0.333)/0.333+c2[0]);
								var num2 = Math.round((c3[1]-c2[1])*(rad_temp-0.333)/0.333+c2[1]);
								var num3 = Math.round((c3[2]-c2[2])*(rad_temp-0.333)/0.333+c2[2]);
								var colorstr = getColorCode(num1,num2,num3);
								var colormat = new THREE.MeshStandardMaterial({color: colorstr});
							} else {
								var num1 = Math.round((c4[0]-c3[0])*(rad_temp-0.666)/0.333+c3[0]);
								var num2 = Math.round((c4[1]-c3[1])*(rad_temp-0.666)/0.333+c3[1]);
								var num3 = Math.round((c4[2]-c3[2])*(rad_temp-0.666)/0.333+c3[2]);
								var colorstr = getColorCode(num1,num2,num3);
								var colormat = new THREE.MeshStandardMaterial({color: colorstr});
							};
							
							let line1 = form_pois_edges_geos[i][j];
							let line2 = form_pois_edges_geos[form_pois_neib_pois[i][j]][form_pois_neib_edges[i][j]];
							var p1 = line1.v1; //顶点1坐标
							var p2 = line1.v2; //顶点2坐标
							var p3 = line2.v2; //顶点3坐标
							var p4 = line2.v1; //顶点4坐标
							var geo = new THREE.Geometry(); //声明一个空几何体对象
							geo.vertices.push(p1,p2,p3); //顶点坐标添加到geometry对象
							var normal = new THREE.Vector3( 0, 0, 1 ); //三角面法向量
							var face = new THREE.Face3( 0, 1, 2, normal); //创建三角面
							geo.faces.push(face); //三角面添加到几何体
							//var face = new THREE.Face3( 2, 3, 1, normal); //创建三角面
							var mesh = new THREE.Mesh(geo,colormat);//网格模型对象
							mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
							mesh.scale.set(0.07, 0.07, 0.07); //缩放
							mesh.castShadow = true;
							if (rad_temp-0==-1) {
								if (external_force_mode==1) {
									group_mink.add(mesh);
								}
							} else {
								group_mink.add(mesh);
							}
							var geo = new THREE.Geometry(); //声明一个空几何体对象
							geo.vertices.push(p3,p4,p1); //顶点坐标添加到geometry对象
							var normal = new THREE.Vector3( 0, 0, 1 ); //三角面法向量
							var face = new THREE.Face3( 0, 1, 2, normal); //创建三角面
							geo.faces.push(face); //三角面添加到几何体
							//var face = new THREE.Face3( 2, 3, 1, normal); //创建三角面
							var mesh = new THREE.Mesh(geo,colormat);//网格模型对象
							mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
							mesh.scale.set(0.07, 0.07, 0.07); //缩放
							mesh.castShadow = true;
							if (rad_temp-0==-1) {
								if (external_force_mode==1) {
									group_mink.add(mesh);
								}
							} else {
								group_mink.add(mesh);
							}
						}
					}
					var box3 = new THREE.Box3();
					// 计算层级模型group的包围盒
					// 模型group是加载一个三维模型返回的对象，包含多个网格模型
					box3.expandByObject(group_mink);
					// 计算一个层级模型对应包围盒的几何体中心在世界坐标中的位置
					var center = new THREE.Vector3();
					box3.getCenter(center);
					// console.log('查看几何体中心坐标', center);
					// 重新设置模型的位置，使之居中。
					group_mink.position.x = group_mink.position.x - center.x;
					group_mink.position.y = group_mink.position.y - center.y;
					group_mink.position.z = group_mink.position.z - center.z;
					scene.add(group_mink);
				}
				
				if (display_mode==1) {
					var vec = new THREE.Vector3(wall_info[3]-wall_info[1], -(wall_info[2]-wall_info[0]));
					vec = vec.normalize();
					var baseShape = new THREE.Shape();
					baseShape.moveTo(wall_info[0], wall_info[1]);
					baseShape.lineTo(wall_info[2], wall_info[3]);
					baseShape.lineTo(wall_info[2]+vec.x*3, wall_info[3]+vec.y*3);
					baseShape.lineTo(wall_info[0]+vec.x*3, wall_info[1]+vec.y*3);
					baseShape.lineTo(wall_info[0], wall_info[1]);
					var extrudedGeometry = new THREE.ExtrudeGeometry(baseShape, {amount: 20, bevelEnabled: false});
					var tmaterial = new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:0.8});
					//tmaterial.opacity = 0.1;
					var extrudedMesh = new THREE.Mesh(extrudedGeometry, tmaterial);
					extrudedMesh.rotation.x = -0.5 * Math.PI; //将模型摆正
					extrudedMesh.position.x = extrudedMesh.position.x - center.x;
					extrudedMesh.position.y = extrudedMesh.position.y - center.y -10;
					extrudedMesh.position.z = extrudedMesh.position.z - center.z;
					scene.add(extrudedMesh);
				}
				
				animate();
				window.onresize = onWindowResize;
				
				var oldnode = document.getElementById("loading");
				oldnode.parentNode.removeChild(oldnode);
				
			}
		}
		
	    function draw_update() {

			while(scene.children.length > 0){ 
				scene.remove(scene.children[0]); 
			}
			
			initLight();
			
			//辅助工具
			var helper = new THREE.AxesHelper(20);
			helper.position.x = -100;
			helper.position.z = -100;
			scene.add(helper);
			
			function deleteGroup(group) {
				//console.log(group);
				if (!group) return;
				// 删除掉所有的模型组内的mesh
				group.traverse(function (item) {
					if (item instanceof THREE.Mesh) {
						item.geometry.dispose(); // 删除几何体
						item.material.dispose(); // 删除材质
					}
				});
			}
			
			deleteGroup(group);
			deleteGroup(group_mink);
			deleteGroup(group_arrow);
			
			geometry = [];
			group = new THREE.Group();
			group_mink = new THREE.Group();
			group_arrow = new THREE.Group();
			minrad = document.getElementById('minumum_radius').value;
			maxrad = document.getElementById('maximum_radius').value;
			mink = document.getElementById("minkowski_sum_indicator").value;
			mat = new THREE.MeshLambertMaterial({color: 0x000000});
			
			console.log("update",minrad,maxrad);
			
			arr_all = content.split('\r\n');
			arr = arr_all.slice(1,parseInt(arr_all[0])+1);
			if (display_mode==1) {
				for (var i = 0; i < arr.length; i++) {
					arr0 = arr[i].split(',');
					if (isNaN(arr0[4])==false) {
						//console.log(arr0);
						
						var p1 = new THREE.Vector3(arr0[0]-0, arr0[1]-0);
						var p2 = new THREE.Vector3(arr0[2]-0, arr0[3]-0);
						let line = new THREE.LineCurve3(p1,p2);
						//console.log(arr0);
						var CurvePath = new THREE.CurvePath();
						CurvePath.curves.push(line);
						
						if (arr0[4]-0==-1) {
							var dir = new THREE.Vector3(((arr0[2]-0)-(arr0[0]-0))*0.07, 0, -((arr0[3]-0)-(arr0[1]-0))*0.07);
							var origin = new THREE.Vector3((arr0[0]-0)*0.07, 0, -(arr0[1]-0)*0.07);
							var length = 6;
							var colorstr = getColorCode(0,100,0);
							var arrowHelper = new THREE.ArrowHelper(dir, origin, length, colorstr, 1.0, 1.0);
							if (external_force_mode==1) {
								group_arrow.add(arrowHelper);
								geometry.push(arrowHelper);
							}
						} else {
							radius = arr0[4]*(maxrad-minrad)+minrad*1.0;
							
							if (arr0[4]-0<0.333) {
								var num1 = Math.round((c2[0]-c1[0])*(arr0[4]-0)/0.333+c1[0]);
								var num2 = Math.round((c2[1]-c1[1])*(arr0[4]-0)/0.333+c1[1]);
								var num3 = Math.round((c2[2]-c1[2])*(arr0[4]-0)/0.333+c1[2]);
								var colorstr = getColorCode(num1,num2,num3);
								var colormat = new THREE.MeshStandardMaterial({color: colorstr});
							} else if (arr0[4]-0<0.666) {
								var num1 = Math.round((c3[0]-c2[0])*(arr0[4]-0.333)/0.333+c2[0]);
								var num2 = Math.round((c3[1]-c2[1])*(arr0[4]-0.333)/0.333+c2[1]);
								var num3 = Math.round((c3[2]-c2[2])*(arr0[4]-0.333)/0.333+c2[2]);
								var colorstr = getColorCode(num1,num2,num3);
								var colormat = new THREE.MeshStandardMaterial({color: colorstr});
							} else {
								var num1 = Math.round((c4[0]-c3[0])*(arr0[4]-0.666)/0.333+c3[0]);
								var num2 = Math.round((c4[1]-c3[1])*(arr0[4]-0.666)/0.333+c3[1]);
								var num3 = Math.round((c4[2]-c3[2])*(arr0[4]-0.666)/0.333+c3[2]);
								var colorstr = getColorCode(num1,num2,num3);
								var colormat = new THREE.MeshStandardMaterial({color: colorstr});
							};
							
							var geometry_temp = new THREE.TubeGeometry(CurvePath, 8, radius, 8, false);
							var mesh = new THREE.Mesh(geometry_temp, colormat);
							mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
							mesh.scale.set(0.07, 0.07, 0.07); //缩放
							mesh.castShadow = true;
							group.add(mesh);
							geometry.push(geometry_temp);
							
							var geometry_temp = new THREE.SphereGeometry(radius, 8, 8);
							var mesh = new THREE.Mesh(geometry_temp, colormat);
							mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
							mesh.scale.set(0.07, 0.07, 0.07); //缩放
							mesh.position.x = arr0[0]*0.07;
							mesh.position.y = 0;
							mesh.position.z = -arr0[1]*0.07;
							mesh.castShadow = true;
							group.add(mesh);
							geometry.push(geometry_temp);
							
							var geometry_temp = new THREE.SphereGeometry(radius, 8, 8);
							var mesh = new THREE.Mesh(geometry_temp, colormat);
							mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
							mesh.scale.set(0.07, 0.07, 0.07); //缩放
							mesh.position.x = arr0[2]*0.07;
							mesh.position.y = 0;
							mesh.position.z = -arr0[3]*0.07;
							mesh.castShadow = true;
							group.add(mesh);
							geometry.push(geometry_temp);
						}
					}
				}
				
				var box3 = new THREE.Box3();
				// 计算层级模型group的包围盒
				// 模型group是加载一个三维模型返回的对象，包含多个网格模型
				box3.expandByObject(group);
				// 计算一个层级模型对应包围盒的几何体中心在世界坐标中的位置
				var center = new THREE.Vector3();
				box3.getCenter(center);
				// console.log('查看几何体中心坐标', center);
				// 重新设置模型的位置，使之居中。
				group.position.x = group.position.x - center.x;
				group.position.y = group.position.y - center.y;
				group.position.z = group.position.z - center.z;
				group_arrow.position.x = group_arrow.position.x - center.x;
				group_arrow.position.y = group_arrow.position.y - center.y;
				group_arrow.position.z = group_arrow.position.z - center.z;
				scene.add(group);
				scene.add(group_arrow);
				
				var plane = new THREE.PlaneGeometry(10000,10000);
				var material = new THREE.MeshPhongMaterial({
					color: 0xFCFCFC,
					// 矩形平面网格模型默认单面显示，可以设置side属性值为THREE.DoubleSide双面显示
				});
				var mesh = new THREE.Mesh(plane, material);
				mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
				mesh.position.y = -30;
				mesh.receiveShadow = true;
				scene.add(mesh);
			}
			
			if (display_mode==2) {
			
				let form_pois_edges_geos = [];
				for (var i = 0; i < form_pois_edges.length; i++) {
					arr0 = [];
					for (var j = 0; j < form_pois_edges[i].length; j++) {
						temp = force_edges[form_pois_edges[i][j]];
						var p1 = new THREE.Vector3(temp.v1.x*mink+form_pois[i].x*(1-mink),temp.v1.y*mink+form_pois[i].y*(1-mink));
						var p2 = new THREE.Vector3(temp.v2.x*mink+form_pois[i].x*(1-mink),temp.v2.y*mink+form_pois[i].y*(1-mink));
						temp = new THREE.LineCurve3(p1,p2);
						arr0.push(temp);
					}
					form_pois_edges_geos.push(arr0);
				}
				
				for (var i = 0; i < form_pois_neib_pois.length; i++) {
					for (var j = 0; j < form_pois_neib_pois[i].length; j++) {
					
						var rad_temp = force_edges_magnitude[form_pois_edges[i][j]];
						if (rad_temp-0==-1) {
							var colorstr = getColorCode(0,100,0);
							var colormat = new THREE.MeshStandardMaterial({color: colorstr});
						}else if (rad_temp-0<0.333) {
							var num1 = Math.round((c2[0]-c1[0])*(rad_temp-0)/0.333+c1[0]);
							var num2 = Math.round((c2[1]-c1[1])*(rad_temp-0)/0.333+c1[1]);
							var num3 = Math.round((c2[2]-c1[2])*(rad_temp-0)/0.333+c1[2]);
							var colorstr = getColorCode(num1,num2,num3);
							var colormat = new THREE.MeshStandardMaterial({color: colorstr});
						} else if (rad_temp-0<0.666) {
							var num1 = Math.round((c3[0]-c2[0])*(rad_temp-0.333)/0.333+c2[0]);
							var num2 = Math.round((c3[1]-c2[1])*(rad_temp-0.333)/0.333+c2[1]);
							var num3 = Math.round((c3[2]-c2[2])*(rad_temp-0.333)/0.333+c2[2]);
							var colorstr = getColorCode(num1,num2,num3);
							var colormat = new THREE.MeshStandardMaterial({color: colorstr});
						} else {
							var num1 = Math.round((c4[0]-c3[0])*(rad_temp-0.666)/0.333+c3[0]);
							var num2 = Math.round((c4[1]-c3[1])*(rad_temp-0.666)/0.333+c3[1]);
							var num3 = Math.round((c4[2]-c3[2])*(rad_temp-0.666)/0.333+c3[2]);
							var colorstr = getColorCode(num1,num2,num3);
							var colormat = new THREE.MeshStandardMaterial({color: colorstr});
						};
						
						let line1 = form_pois_edges_geos[i][j];
						let line2 = form_pois_edges_geos[form_pois_neib_pois[i][j]][form_pois_neib_edges[i][j]];
						var p1 = line1.v1; //顶点1坐标
						var p2 = line1.v2; //顶点2坐标
						var p3 = line2.v2; //顶点3坐标
						var p4 = line2.v1; //顶点4坐标
						var geo = new THREE.Geometry(); //声明一个空几何体对象
						geo.vertices.push(p1,p2,p3); //顶点坐标添加到geometry对象
						var normal = new THREE.Vector3( 0, 0, 1 ); //三角面法向量
						var face = new THREE.Face3( 0, 1, 2, normal); //创建三角面
						geo.faces.push(face); //三角面添加到几何体
						//var face = new THREE.Face3( 2, 3, 1, normal); //创建三角面
						var mesh = new THREE.Mesh(geo,colormat);//网格模型对象
						mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
						mesh.scale.set(0.07, 0.07, 0.07); //缩放
						mesh.castShadow = true;
						if (rad_temp-0==-1) {
							if (external_force_mode==1) {
								group_mink.add(mesh);
							}
						} else {
						    group_mink.add(mesh);
						}
						var geo = new THREE.Geometry(); //声明一个空几何体对象
						geo.vertices.push(p3,p4,p1); //顶点坐标添加到geometry对象
						var normal = new THREE.Vector3( 0, 0, 1 ); //三角面法向量
						var face = new THREE.Face3( 0, 1, 2, normal); //创建三角面
						geo.faces.push(face); //三角面添加到几何体
						//var face = new THREE.Face3( 2, 3, 1, normal); //创建三角面
						var mesh = new THREE.Mesh(geo,colormat);//网格模型对象
						mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
						mesh.scale.set(0.07, 0.07, 0.07); //缩放
						mesh.castShadow = true;
						if (rad_temp-0==-1) {
							if (external_force_mode==1) {
								group_mink.add(mesh);
							}
						} else {
						    group_mink.add(mesh);
						}
					}
				}
				
				var box3 = new THREE.Box3();
				// 计算层级模型group的包围盒
				// 模型group是加载一个三维模型返回的对象，包含多个网格模型
				box3.expandByObject(group_mink);
				// 计算一个层级模型对应包围盒的几何体中心在世界坐标中的位置
				var center = new THREE.Vector3();
				box3.getCenter(center);
				// console.log('查看几何体中心坐标', center);
				// 重新设置模型的位置，使之居中。
				group_mink.position.x = group_mink.position.x - center.x;
				group_mink.position.y = group_mink.position.y - center.y;
				group_mink.position.z = group_mink.position.z - center.z;
				scene.add(group_mink);
				
			}
			
			if (display_mode==1) {
				var vec = new THREE.Vector3(wall_info[3]-wall_info[1], -(wall_info[2]-wall_info[0]));
				vec = vec.normalize();
				var baseShape = new THREE.Shape();
				baseShape.moveTo(wall_info[0], wall_info[1]);
				baseShape.lineTo(wall_info[2], wall_info[3]);
				baseShape.lineTo(wall_info[2]+vec.x*3, wall_info[3]+vec.y*3);
				baseShape.lineTo(wall_info[0]+vec.x*3, wall_info[1]+vec.y*3);
				baseShape.lineTo(wall_info[0], wall_info[1]);
				var extrudedGeometry = new THREE.ExtrudeGeometry(baseShape, {amount: 20, bevelEnabled: false});
				var tmaterial = new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:0.8});
				//tmaterial.opacity = 0.1;
				var extrudedMesh = new THREE.Mesh(extrudedGeometry, tmaterial);
				extrudedMesh.rotation.x = -0.5 * Math.PI; //将模型摆正
				extrudedMesh.position.x = extrudedMesh.position.x - center.x;
				extrudedMesh.position.y = extrudedMesh.position.y - center.y -10;
				extrudedMesh.position.z = extrudedMesh.position.z - center.z;
				scene.add(extrudedMesh);
			}
		}
	</script>
</body>
</html>